# 🛠️ JKGameHotKey

> **Note**: 문서 작성에 제미나이의 도움을 받았음.

---

## 💡 The "Aha" Moment: 시작된 계기

### "기능은 있지만, 내 손에 맞지 않는다면 없는 것과 다름없다."

이 프로젝트는 **소녀전선 2 (GF2)** PC 클라이언트를 플레이하며 느낀 작은 결핍에서 시작되었습니다. 게임 내에 단축키 시스템이 존재함에도 불구하고 다음과 같은 치명적인 불편함이 있었습니다:

* **고정된 단축키**: 사용자가 익숙한 키로 재설정(Remap)할 수 없는 폐쇄적인 구조.
* **누락된 메뉴**: 정작 자주 쓰이는 메뉴에는 단축키가 배정되어 있지 않아 마우스 조작이 강제됨.
* **학습 장벽**: 게임 초기, 수많은 단축키를 일일이 외워야 하는 번거로움.

처음에는 외부 프로그램을 찾아볼까 고민도 했습니다. 하지만 **"내 코딩 능력을 활용해 나에게 딱 맞는 유연한 도구를 직접 만드는 것이 가장 빠르고 확실한 해결책"** 이라는 결론에 도달했습니다. 
그렇게 탄생한 초기 모델 gf2hotkey는 점차 기능을 넓혀, 현재는 어떤 게임이나 프로그램에도 대응할 수 있는 JKGameHotKey로 진화했습니다.

---

## 🏗️ Architecture: '단일 실행'을 위한 구조적 진화
초기에는 하나의 게임만을 위한 전용 구조였으나, 지원하는 게임이 늘어남에 따라 **"게임마다 스크립트를 따로 켜는 번거로움"** 을 해결하기 위해 단일 상주형 및 계층적 데이터 구조로 확장했습니다.

* **마스터 인덱스 시스템**: JK_AHK_SheetNameKey.csv가 모든 게임의 프로세스명과 데이터 경로를 중앙 제어합니다.
* **Relational Data Management**: 인덱스 시트가 하위 폴더의 전용 데이터 시트(a, b, c...)를 참조하는 구조를 채택하여, 수많은 설정값을 코드 수정 없이 체계적으로 관리할 수 있습니다.
* **Single Path Control**: 모든 경로는 A_ScriptDir을 기준으로 동적으로 할당되어 이동 및 배포가 자유로운 환경을 제공합니다.
* **Modularization (`Utility.ahk`)**: 다른 프로젝트에서도 재사용 가능한 가상키 클래스와 공용 함수를 라이브러리화하여 코드의 유지보수성을 극대화했습니다.

---

## 🚀 Optimization & Logic: 동적 로드가 가져온 3가지 혁신
이 프로젝트의 핵심인 '활성화 시점의 동적 로드' 설계는 단순히 작동하는 것을 넘어 성능과 사용자 경험에서 강력한 이점을 제공합니다.

* **Event-Driven Resource Management**:
CPU를 상시 점유하는 무한 루프(SetTimer) 대신, 윈도우의 **창 활성화 이벤트(Focus Event)** 에만 반응합니다. 게임 창이 전면에 올 때만 영리하게 동작하여 시스템 리소스 점유를 최소화했습니다.

* **Universal Compatibility (단일 스크립트 범용성)**:
사용자는 게임마다 별도의 스크립트를 실행할 필요가 없습니다. 단 하나의 스크립트만 켜두면, 인덱스에 등록된 어떤 게임이든 활성화되는 순간 해당 가상키를 즉시 매핑합니다.

* **Hot-Reloading Workflow (실시간 반영)**:
* 창 전환 시마다 시트를 새로 읽어오기 때문에, **CSV 설정 변경 후 게임 창을 다시 클릭(활성화)** 하는 것만으로 수정 사항이 즉시 적용됩니다. 코드 수정이나 스크립트 재시작의 번거로움이 없는 쾌적한 커스터마이징 환경을 제공합니다.
* `setting.ini`를 통해 오버레이 상태 등 사용자 설정을 보존하여 재실행 시에도 이전 환경을 유지합니다.

* **Self-Terminate Cleanliness**:
감지된 대응 게임이 모두 종료되거나 없을 경우, 백그라운드에 불필요하게 상주하지 않고 스스로 종료되어 시스템 청결을 유지합니다.

---

## ✨ Key Features: 데이터 중심의 커스텀 매핑

`JKGameHotKey`는 사용자가 작성한 **CSV 데이터**를 기반으로 가상 단축키를 실시간 생성 및 할당합니다.

### 1. Data-Driven Virtual Keys `Core`

* **CSV 기반 매핑**: 정해진 규격의 CSV 시트에 정보를 입력하는 것만으로 가상 단축키 시스템을 즉시 구축합니다.
* **Zero-Code Extension**: 새로운 키가 필요할 때 소스 코드를 수정할 필요 없이, 시트의 행(`Row`)만 추가하여 기능을 확장할 수 있습니다.

### 2. Guide Overlay `Sub`

* **실시간 위치 시각화**: 현재 로드된 가상키가 화면 좌표 어디에 위치하는지 **50% 반투명 텍스트 박스**로 출력합니다.
* **직관적 디버깅**: 시트 작성 후 설정한 좌표가 실제 게임 버튼 위에 정확히 일치하는지 즉각적인 검증이 가능합니다.
* **상태 보존**: 오버레이 활성화 여부는 `setting.ini`에 저장되어 프로그램 재시작 시에도 유지됩니다.

### 3. Window Layout Manager `Utility`

* **플레이 환경 최적화**: 게임 창을 사전에 정의된 규격(`JK_GameDefaultPosition.csv`)에 맞춰 정렬합니다.
* **좌표 정밀도 유지**: 창의 위치를 고정함으로써 해상도 변화나 창 이동으로 인한 가상키 좌표 오차를 원천 차단합니다.

---

## ⚙️ Data Flow: 데이터 처리 프로세스

JKGameHotKey는 단순한 스크립트 실행이 아닌, 객체 지향적 파싱과 이벤트 기반 로직을 통해 데이터를 동적으로 처리합니다.

### 🔄 Runtime Lifecycle

1. **Process Detection**
창 활성화 이벤트 발생 시, 현재 포커스된 프로세스 명을 실시간으로 감지합니다.
2. **Master Index Lookup**
`JK_AHK_SheetNameKey.csv`에서 감지된 프로세스 명(Key)을 대조하여, 대응하는 가상키 시트 경로(Value)를 획득합니다. (예: `KeyData/시트명.csv`)
3. **Data Parsing & Objectification**

* 획득한 CSV를 로드하여 `name`, `x`, `y`, `type`, `description` 컬럼을 파싱합니다.
* 각 행(Row)의 데이터를 **가상키 관리 클래스**의 인스턴스로 변환하여 객체 배열에 저장합니다.

4. **Dynamic Mapping**
생성된 가상키 객체 배열을 순회하며 AutoHotkey의 `HotKey` 함수를 통해 실시간으로 가상키를 할당합니다.
5. **Cleanup & Loop**
창이 비활성화되면 등록된 가상키를 일괄 제거하여 리소스를 반환하며, 다음 활성화 이벤트를 대기합니다.

---

## 🛠️ Additional Utility

### Window Layout Manager (Global Hotkey)

게임 환경의 일관성을 위해 창의 위치와 크기를 강제로 제어하는 기능을 제공합니다.

* **작동 방식**: `JK_GameDefaultPosition.csv` 시트에 정의된 좌표 데이터를 참조합니다.
* **실행**: 전역 단축키(`F7`)를 누르면 해당 시트의 설정값에 따라 활성화된 게임 창을 지정된 위치로 즉시 이동 및 정렬합니다.
* **이점**: 멀티 모니터나 다양한 해상도 환경에서도 가상키 좌표의 정밀도를 항상 동일하게 유지할 수 있습니다.

---
